{
	"nodes":[
		{"id":"62008a15260c0732","x":-272,"y":-1190,"width":725,"height":426,"type":"text","text":"ParserOmfl\n1. структура для парсинга\n2. френд функции для парсинга\n3. функции для проверки на тип значения\n4. valid\n5. вектор векторов секций. Если секция без подсекций, пушу вектор состоящий из одного названия одной секции. Если насколько секций через точку, (проверяю, есть ли первая секция в списке и если да, то пушу в ее вектор названия других секций) пушу первую секцию и дальше в вектор из этой секцией пушу названия других секций\n\n"},
		{"id":"8fbc3a373e5c388d","x":-1425,"y":-939,"width":356,"height":350,"type":"text","text":"Класс MultiValue\n1. название ключа\n2. строка со значением ключа\n3. вектор со значениями из массива\n4. вектор типов значений из массива\n5. чар отвечающий за тип значения (если нет массива)\n6. Все IS AS и тд функции"},
		{"id":"19165569e57d596c","x":-1847,"y":13,"width":844,"height":654,"type":"text","text":"Как получить вектор значений массива (все значения между запятыми)\n```cpp\n// push to vector_to_array values from array (all between , )  \nstd::vector<std::string> vector_to_array;  \nstd::string string;  \nint ind = 0;  \nint count_commas = std::count(var.key_value.begin(), var.key_value.end(), ',');  \nfor (int h = 0; h < count_commas; ++h) {  \n    while (var.key_value[ind] != ',') {  \n        string += var.key_value[ind];  \n        ind++;  \n    }  \n    ind++;  \n    vector_to_array.push_back(string);  \n    string = \"\";  \n}  \n  \n// find position of last comma  \nstd::reverse(var.key_value.begin(), var.key_value.end());  \nint position_of_last_comma = var.key_value.find(',');  \nstd::reverse(var.key_value.begin(), var.key_value.end());  \nstd::string value_after_last_comma = var.key_value.substr(  \n        var.key_value.length() - position_of_last_comma, var.key_value.length() - 1);  \nvector_to_array.push_back(value_after_last_comma);\n```"},
		{"id":"1363d9eacb8eb2f0","x":-708,"y":-631,"width":1089,"height":1065,"color":"3","type":"text","text":"Парсинг аргументов\n**Переменные**:\n- вектор строк для случая, когда строки для парса даны через перенос строки (как во 2 файле)\n**Ход парса**:\n- проверка на наличие #. Если после него идет перенос строки - invalidCase\n- проверка на пустую строку, переданную в функцию парс\n- считаю количество переносов строк. Далее удаляю первый перенос строки и в вайле вычленяю строки между переносами строк (если строк только одна, пушу ее и иду дальше)\n- прохожусь по вектору строк при помощи auto:\n\t- елси в строка пустаая - инвалид\n\t- снова проверяю на комментарий (и удаляю все после # и если строка получилась пустой (после удаления всех пробелов) - игнорирую)\n\t- считаю количество =. Далее расхожусь на 3 ифа:\n\t\t- если нет равно:\n\t\t\t- проверяю на секцию: проверяю есть ли [ и ]. Удаляю их, если строка не пустая стала, проверяю на невалидные символы, затем на повторяющиеся имена секций. Считаю количество точек. Если нет - считываю название секции и пушу в вектор. Если есть точка, проверяю, нет ли пустой строки вместо названия секции и если нет, то пушу либо вектор вектора (если нет точек в названии), либо в последний вектор вектора (если есть точка)\n\t\t\t- Если равно > 1 - инвалид\n\t\t\t\t- если одно равно:  выделяю key_name и key_value при помощи substr и индекса =. Удаляю лишние пробелы из key_value и key_name. Проверяю на невалидные символы в  key_name, затем на повторяющиеся имена (если есть - инвалид). Далее для key_value: считаю количество [ и количество ]. Если первый символ в value это [ и при этом количество квадрантных скобок по одной - случай с массивом. Записываю в отдельный вектор значения между запятыми и затем прохожусь по этому вектору. Определяю тип key_value и пушу только value, тип value, пушу в вектор multivalue value и записываю это в отдельный объект mult класса multivalue. ]\n\t\t\t\t- Если количество квадратных скобочек каждого типа больше, чем 1 - двумерные массивы\n\t\t\t\t- else - не массив. Проверяю на каждый типа. Сначала строка - Считаю количество кавычек. Если их больше, чем две или одна - инвалид. Если кавычек ровно две - запускаю функцию проверку на строку"},
		{"id":"cdcdd9abf44ad38a","x":-1316,"y":713,"width":757,"height":562,"type":"text","text":"Как получить вектор отдельных строк между переносами строки:\n```cpp\nnt count_line_breaks = std::count(string1.begin(), string1.end(), '\\n');  \nstd::string strr;  \nint r = count_line_breaks;  \nint index_line_break;  \nif (count_line_breaks != 0) {  \n    index_line_break = string1.find('\\n'); // in the 0 index of string there is line_break  \n    string1.erase(index_line_break, index_line_break + 1); // delete 0 index line_break  \n    while (r != 0) {  \n        index_line_break = string1.find('\\n');  \n        strr = string1.substr(0, index_line_break);  \n        vector_of_stirngs.push_back(strr);  \n        string1.erase(0, index_line_break + 1);  \n        r--;  \n    }  \n} else {  \n    vector_of_stirngs.push_back(string1);  \n}\n```\n"},
		{"id":"70047dfe7acfca7b","x":-438,"y":1064,"width":529,"height":390,"type":"text","text":"Как удалять лишние пробелы:\n```cpp\nwhile (var.key_value[0] == ' ') {  \n    var.key_value.erase(0, 1);  \n}  \nstd::reverse(var.key_value.begin(), var.key_value.end());  \nwhile (var.key_value[0] == ' ') {  \n    var.key_value.erase(0, 1);  \n}  \nstd::reverse(var.key_value.begin(), var.key_value.end());\n```"},
		{"id":"10f427455dee624d","x":91,"y":1189,"width":834,"height":1156,"type":"text","text":"Как записывать секции (в том числе вложенные)\n```cpp\nstd::string after_dot;  \nstd::string before_dot;  \nint index;  \nint count = std::count(str.begin(), str.end(), '.');  \nfor (int i = 0; i < count; ++i) {  \n    index = str.find('.');  \n    after_dot = str.substr(index + 1, str.length() - 1);  \n    before_dot = str.substr(0, index);  \n    if ((after_dot.length() == 0) or (before_dot.length() == 0)) {  \n        invalidCase(multiValueClass);  \n        return parserOmfl;  \n    }  \n    str.erase(0, index + 1);  \n}  \n  \n// write sections and subsections  \nstr += '.'; // it's for help to get all sections name (with the last one)  \ncount_dots_in_section_name++;  \nint index_dot = str.find('.');  \nstd::string section_name = str.substr(0, index_dot);  \nfor (int j = 0; j < omfl::ParserOMFL::sections.size(); ++j) {  \n    for (int k = 0; k < omfl::ParserOMFL::sections[j].size(); ++k) {  \n        if (section_name == omfl::ParserOMFL::sections[j][k]) {  \n            for (int i = 0; i < count_dots_in_section_name - 1; ++i) {  \n                str.erase(0, index_dot + 1);  \n                index_dot = str.find('.');  \n                section_name = str.substr(0, index_dot);  \n                if (section_name.length() == 0) {  \n                    invalidCase(multiValueClass);  \n                    return parserOmfl;  \n                }  \n                omfl::ParserOMFL::sections[j].push_back(section_name);  \n            }  \n            return parserOmfl; // уже обработали строку, дальше идти нет смысла  \n  \n        }  \n    }  \n}  \nfor (int i = 0; i < count_dots_in_section_name; ++i) {  \n    if (omfl::ParserOMFL::sections.size() == 0) {  \n        std::vector<std::string> one_section;  \n        one_section.push_back(section_name);  \n        omfl::ParserOMFL::sections.push_back(one_section);  \n        str.erase(0, index_dot + 1);  \n        index_dot = str.find('.');  \n        section_name = str.substr(0, index_dot);  \n  \n    } else {  \n        if(str.length() == 0) {  \n            continue;  \n        }  \n        omfl::ParserOMFL::sections[omfl::ParserOMFL::sections.size() - 1].push_back(section_name);  \n        str.erase(0, index_dot + 1);  \n        index_dot = str.find('.');  \n        section_name = str.substr(0, index_dot);  \n  \n    }  \n}\n\n```"},
		{"id":"6b7570b3358edb09","x":725,"y":276,"width":531,"height":718,"color":"4","type":"text","text":"## Проверка на int\n```cpp\nint l = 0;  \nif (key_value[0] == '+' or key_value[0] == '-') {  \n    l++;  \n}  \nfor (int m = l; m < key_value.length(); ++m) {  \n    if (std::isdigit(key_value[m]) == 0) { // cases: 2-2, 134llll,  \n        return false;  \n    }  \n}  \nreturn true;\n```"},
		{"id":"fa07ac13c79f4b41","x":830,"y":-1349,"width":853,"height":718,"color":"4","type":"text","text":"## Проверка на строку\n```cpp\nbool omfl::CheckForStringValue(std::string& key_value) {  \n    // посчитаю длину строки между кавычками и если после удаления кавычек  \n    // длина строки окажется такой же, значит лишних значений не было    if (key_value[0] == '\\\"') { // if before \" there are some symbols  \n        int counter = 0; // counter of symbols between quotation  \n        int n = key_value.find('\\\"');  \n        // count of symbols between quotations  \n        for (int k = n + 1; k < key_value.length(); ++k) {  \n            if (key_value[k] == '\\\"') {  \n                break;  \n            }  \n            counter++;  \n        }  \n        key_value.erase(n, n + 1); // delete first quotation  \n        n = key_value.find('\\\"'); // find second quotation  \n        key_value.erase(n, n + 1); // delete second quotation  \n  \n        // \"string\", lskdjfsklfdj - is invalid        if (key_value.length() != counter) {  \n            return false;  \n  \n        } else { // \"string\" - is valid  \n            return true;  \n        }  \n    }  \n}\n```"},
		{"id":"13893a30ed8f762c","x":1683,"y":-631,"width":765,"height":718,"color":"4","type":"text","text":"## Проверка на float\n```cpp\nbool omfl::CheckForFloatValue(std::string& key_value) {  \n    std::string after_dot;  \n    std::string before_dot;  \n    int dot = key_value.find('.');  \n    before_dot = key_value.substr(0, dot);  \n    after_dot = key_value.substr(dot + 1, key_value.length() - 1);  \n  \n    // cases: 0.  1.  123213.  \n    if (before_dot.length() == 0 or after_dot.length() == 0) {  \n        return false;  \n    }  \n    if (key_value[0] == '+' or key_value[0] == '-') {  \n        if (std::isdigit(key_value[1]) == false) {  \n            return false;  \n        }  \n    }  \n    // check for invalid symbols in key_value (cases: 1.34234,23)  \n    for (int k = 0; k < key_value.length(); ++k) {  \n        if ((key_value[k] != '.') and (std::isdigit(key_value[k]) == -1)) {  \n            return false;  \n        }  \n    }  \n    return true;  \n}\n```"},
		{"id":"96538e18781fadb1","x":1375,"y":276,"width":747,"height":718,"color":"4","type":"text","text":"## Функция Get\n```cpp\nomfl::MultiValueClass& omfl::ParserOMFL::Get(std::string key_name_) const {  \n//    int index_dot = key_name_.find('.');  \n//    std::string section_name = key_name_.substr(0, index_dot);  \n//    bool section = false;  \n//    for (int i = 0; i < sections.size(); ++i) {  \n//        for (int j = 0; j < sections[i].size(); ++j) {  \n//            if (section_name == sections[i][j]) {  \n//                section = true;  \n//            }  \n//        }  \n//    }else {  \n    for (int i = 0; i < vector_multi_values.size(); ++i) {  \n        if(vector_multi_values[i].key_name == key_name_) {  \n            return vector_multi_values[i];  \n        }  \n    }  \n  \n}\n```"}
	],
	"edges":[
		{"id":"1fd092de47280586","fromNode":"1363d9eacb8eb2f0","fromSide":"right","toNode":"fa07ac13c79f4b41","toSide":"left"},
		{"id":"6277d5f3c6a22258","fromNode":"1363d9eacb8eb2f0","fromSide":"left","toNode":"19165569e57d596c","toSide":"right"},
		{"id":"e9e7bc2c9f352948","fromNode":"1363d9eacb8eb2f0","fromSide":"bottom","toNode":"70047dfe7acfca7b","toSide":"top"},
		{"id":"46ce4d734edaa159","fromNode":"1363d9eacb8eb2f0","fromSide":"bottom","toNode":"cdcdd9abf44ad38a","toSide":"top"},
		{"id":"8ce451e96a91f383","fromNode":"1363d9eacb8eb2f0","fromSide":"right","toNode":"13893a30ed8f762c","toSide":"left"},
		{"id":"6df2fe1cb5030a0b","fromNode":"1363d9eacb8eb2f0","fromSide":"right","toNode":"6b7570b3358edb09","toSide":"top"},
		{"id":"3e31a1fe22b12cea","fromNode":"1363d9eacb8eb2f0","fromSide":"bottom","toNode":"10f427455dee624d","toSide":"top"},
		{"id":"1066745620b1e379","fromNode":"1363d9eacb8eb2f0","fromSide":"right","toNode":"96538e18781fadb1","toSide":"top"}
	]
}