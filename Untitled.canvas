{
	"nodes":[
		{"id":"04b1915e0ea78ce7","x":-167,"y":-878,"width":394,"height":101,"type":"text","text":"## namespace omfl"},
		{"id":"847f29caa29a0830","x":30,"y":-678,"width":367,"height":361,"color":"#121fce","type":"text","text":"**parse(const std::filesystem::path & path)**\n-  построчно достаю строки из файла и кладу их в вектор lines_from_file\n- после того, как все строки считаны, прохожусь по вектору и вызываю функцию parse(const std::string str) и паршу строки"},
		{"id":"2beace61b4fe2650","x":-353,"y":-678,"width":242,"height":299,"color":"2","type":"text","text":"**Class MultiValue**\n- key_name\n- string_key_value\n- int_key_value\n- bool_key_value\n- type_of_value (0 1 2 3)\n- is_valid"},
		{"id":"d2d969f27448a19c","x":-292,"y":-317,"width":598,"height":750,"type":"text","text":"parse(const std::string str)\n### Парсинг на key-value\n0. создаю объект класса MultiValue, в нем делаю флаг valid=false и type_of_value = '3'\n1. считаю количество равно (если их больше двух -делаю пункт 0 )\n2. если нахожу перенос строки - пункт 0\n3. удаляю лишние пробелы в строке - https://ru.stackoverflow.com/questions/1151422/%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2-%D0%B8%D0%B7-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8\n4. нахожу индекс = и  при помощи substr заполняю переменную key_name. Если key_name.length() == 0 - пункт 0\n5. при помощи уже найденного индекса = заполняю переменную key_value. Если key_value.length() == 0 -> пункт 0\n### Valid check for key_name\n1. Для каждого элемента - если элемент не присутствует в разрешенной строке - 0 пункт\n### Valid check for key_value\nнаписать методы в классе ParserOMFL IsInt, IsString и тд и к ним обращаться\n1. Случай с инт или float\n\t- Прохожусь по строке и смотрю, есть ли две кавычки (если кавычек нечетное количество - 0 пункт). Если есть четное число кавычек (может быть массив со строками) - перехожу к случаю со строкой. Если нет кавычек - перехожу к случаю с бул, если не бул - продолжаю\n\t- Прохожусь по строке и ищу точку. Если количество точек == 1, проверяю, является ли первый элемент key_value плюсом, минусом (и при этом следующий элемент число) или является ли он числом. Если не является - перехожу к случаю с секцией\n\t- Прохожусь по строке и смотрю, нет  ли посторонних знаков кроме цифр и одного+ или одного- Если не выполнилось - пункт 0\n2. Случай со строкой\n\t- если кавычек больше 2 - случай с массивом. \n\t- Удаляю из key_value кавычки\n1. Случай с bool\n2. Случай с массивом\n3. Случай с секцией"},
		{"id":"88224160339a7bf8","x":444,"y":-651,"width":636,"height":378,"color":"1","type":"text","text":"**Class ParserOMFL**\n ```cpp\nstd::vector<MultiValueClass> vector_multi_values = {}\n\nfriend omfl::ParserOMFL& parse(const std::filesystem::path& path);  \nfriend omfl::ParserOMFL& parse(std::string str);\n```\n- bool valid() - берет последнее значение из вектора vector_multi_values и возвращает флаг в последнем добавленном объекте (если вектор пустой, возвращает тру). Если type_of_value == 3, возвращаю фолс и удяляю этот объект (так как в нем нет значения и\\или значение или ключ были невалидны) при помощи std::vector::erase"}
	],
	"edges":[
		{"id":"47fc1b774bf36bf5","fromNode":"04b1915e0ea78ce7","fromSide":"bottom","toNode":"847f29caa29a0830","toSide":"top"},
		{"id":"a61f021ce215066b","fromNode":"04b1915e0ea78ce7","fromSide":"bottom","toNode":"2beace61b4fe2650","toSide":"top"},
		{"id":"74bd1fc0ad74447c","fromNode":"04b1915e0ea78ce7","fromSide":"right","toNode":"88224160339a7bf8","toSide":"top"}
	]
}