{
	"nodes":[
		{"id":"04b1915e0ea78ce7","x":-429,"y":-972,"width":394,"height":101,"type":"text","text":"## namespace omfl"},
		{"id":"2beace61b4fe2650","x":-1000,"y":-678,"width":362,"height":299,"color":"2","type":"text","text":"**Class MultiValue**\n- key_name\n- std::string key_value // будем даункастить эту переменную в инт, бул, флоат\n- char type_of_value // 0-int, 1-string 2-bool, 3-no any values\n- is_valid"},
		{"id":"847f29caa29a0830","x":-200,"y":-709,"width":367,"height":361,"color":"#121fce","type":"text","text":"**parse(const std::filesystem::path & path)**\n-  построчно достаю строки из файла и кладу их в вектор lines_from_file\n- после того, как все строки считаны, прохожусь по вектору и вызываю функцию parse(const std::string str) и паршу строки"},
		{"id":"88224160339a7bf8","x":513,"y":-478,"width":719,"height":1078,"color":"1","type":"text","text":"**Class ParserOMFL**\n ```cpp\nstd::vector<MultiValueClass> vector_multi_values = {}\nstd::vector<std::string> vector_key_names; // for checking repeated key_names\nfriend omfl::ParserOMFL& parse(const std::filesystem::path& path);  \nfriend omfl::ParserOMFL& parse(std::string str);\n```\n- **bool valid()** -\n\t- берет последнее значение из вектора vector_multi_values и возвращает флаг в последнем добавленном объекте (если вектор пустой, возвращает тру). Если type_of_value == 3, возвращаю фолс и удяляю этот объект (так как в нем нет значения и\\или значение или ключ были невалидны) при помощи std::vector::erase\n- **MultiValue multivalue** - \n\t- в нее будет класть объект из вектор метод гет и это значение будет использовать метод IsInt или AsIntOrDefault, изменять его и пушить в вектор обратно (такой же или уже измененный)\n- **Get(std::stirng str)**: ПЕРЕДЕЛАТЬ, ЧТОБЫ ОН ВОЗВРАЩАЛ ОБЪЕКТ КЛАССА MULTIVALUE\n\t- проходит по вектору multi_value_vector и находит в нем объект в котором есть ключ == str.\n\t- Записывает в переменную класса multiValue этот объект (чтобы потом AsInt IsInt или AsIntOrDefault могли к ней обращаться)\n- **AsInt()**:\n\t- обращается к key_value в omfl::ParserOMFL::multiValue при помощи typeid().name() возвращает тру или фолс\n- **IsInt()**:\n\t- при помощи typeid().name() возвращает тру или фолс\n- **IsFloat()**:\n\t- при помощи typeid().name() возвращает тру или фолс\n- **IsString()**:\n\t- при помощи typeid().name возвращает тру или фолс\n- **AsStringOrDefault(const std::string string**):\n\t- присваивает значение key_value значению переменной string\n- "},
		{"id":"d2d969f27448a19c","x":-1012,"y":-288,"width":916,"height":1285,"color":"6","type":"text","text":"parse(const std::string str)\n### Парсинг на key-value\n0. создаю объект класса MultiValue, в нем делаю флаг valid=false и type_of_value = '3'\n1. считаю количество равно (если их больше двух -делаю пункт 0 )\n2. если нахожу перенос строки - пункт 0\n3. удаляю лишние пробелы в строке - https://ru.stackoverflow.com/questions/1151422/%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D1%85-%D1%81%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2-%D0%B8%D0%B7-%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8\n4. нахожу индекс = и  при помощи substr заполняю переменную key_name. Если key_name.length() == 0 - пункт 0\n5. при помощи уже найденного индекса = заполняю переменную key_value. Если key_value.length() == 0 -> пункт 0\n### Valid check for key_name\n1. Для каждого элемента - если элемент не присутствует в разрешенной строке - 0 пункт\n2. Прохожусь по vector_key_names и если в нем уже содержится подобное имя, 0 пункт\n### Valid check for key_value\nнаписать методы в классе ParserOMFL IsInt, IsString и тд и к ним обращаться\n1. Случай с инт или float\n\t- Прохожусь по строке и смотрю, есть ли две кавычки (если кавычек нечетное количество - 0 пункт). Если есть четное число кавычек (может быть массив со строками) - перехожу к случаю со строкой. Если нет кавычек - перехожу к случаю с бул, если не бул - продолжаю\n\t- Прохожусь по строке и ищу точку. Если количество точек == 1, проверяю, является ли первый элемент key_value плюсом, минусом (и при этом следующий элемент число) или является ли он числом. Если не является - перехожу к случаю с секцией\n\t- Прохожусь по строке и смотрю, нет  ли посторонних знаков кроме цифр и одного+ или одного- или буквы f. Если не выполнилось - пункт 0\n2. Случай со строкой\n\t- если кавычек больше 2 - случай с массивом. \n\t- Удаляю из key_value кавычки\n3. Случай с bool\n\t- если значение в строке key_value совпадает со словом true или false , ставлю соответствующий флаг\n4. Случай с массивом\n\t- проверяю, сколько открывающих квадратных скобочек и закрывающих. Если и тех, и тех - 0 - 0 пункт\n\t- Если количество открывающих != закрыающих - 0 пункт\n\t- Если \n1. Случай с секцией"}
	],
	"edges":[
		{"id":"47fc1b774bf36bf5","fromNode":"04b1915e0ea78ce7","fromSide":"bottom","toNode":"847f29caa29a0830","toSide":"top"},
		{"id":"a61f021ce215066b","fromNode":"04b1915e0ea78ce7","fromSide":"bottom","toNode":"2beace61b4fe2650","toSide":"top"},
		{"id":"74bd1fc0ad74447c","fromNode":"04b1915e0ea78ce7","fromSide":"right","toNode":"88224160339a7bf8","toSide":"top"},
		{"id":"d231fc8e51d9ccea","fromNode":"04b1915e0ea78ce7","fromSide":"bottom","toNode":"d2d969f27448a19c","toSide":"top"},
		{"id":"9e51959db841ff91","fromNode":"847f29caa29a0830","fromSide":"right","toNode":"88224160339a7bf8","toSide":"left","color":"#000000","label":"friend"},
		{"id":"acaf432a87433c08","fromNode":"d2d969f27448a19c","fromSide":"right","toNode":"88224160339a7bf8","toSide":"left","color":"#000000","label":"friend"}
	]
}