{
	"nodes":[
		{"id":"c1a3ea5e739261c0","x":-767,"y":-764,"width":326,"height":331,"color":"3","type":"text","text":"Структура Section:\n1. название секции (no section == нет секции)\n2. ссылка на следующую секцию\n3. вектор из MultiValue классов"},
		{"id":"8fbc3a373e5c388d","x":-797,"y":-339,"width":356,"height":350,"type":"text","text":"Класс MultiValue\n1. название ключа\n2. строка со значением ключа\n3. вектор со значениями из массива\n4. вектор типов значений из массива\n5. чар отвечающий за тип значения (если нет массива)\n6. Все IS AS и тд функции"},
		{"id":"f9e950b728005293","x":573,"y":-619,"width":390,"height":316,"type":"text","text":"Как получить значение с помощью Get\n1. Если нет точек в строке - заходим в секцию no section и там в векторе ищем по ключу и возвращаем значение"},
		{"id":"62008a15260c0732","x":-272,"y":-646,"width":725,"height":426,"type":"text","text":"ParserOmfl\n1. структура для парсинга\n2. френд функции для парсинга\n3. функции для проверки на тип значения\n4. valid\n5. вектор векторов секций. Если секция без подсекций, пушу вектор состоящий из одного названия одной секции. Если насколько секций через точку, (проверяю, есть ли первая секция в списке и если да, то пушу в ее вектор названия других секций) пушу первую секцию и дальше в вектор из этой секцией пушу названия других секций\n\n"},
		{"id":"1363d9eacb8eb2f0","x":-272,"y":-128,"width":571,"height":516,"color":"3","type":"text","text":"Парсинг аргументов\n1. если даны секции через точки, пушу "},
		{"id":"10f427455dee624d","x":316,"y":93,"width":834,"height":1156,"type":"text","text":"Как записывать вложенные секции\n```cpp\nstd::vector<std::vector<std::string>> sections = {{\"section1\"}};  \nstd::string string = \"section1.section-2.section3\";  \nstring += '.'; // it's for help to get all sections name (with the last one)  \nint count_dots = std::count(string.begin(), string.end(), '.');  \n  \nif (count_dots == 0) {  \n    std::vector<std::string> one_section;  \n    one_section.push_back(string);  \n    sections.push_back(one_section);  \n} else {  \n    int index_dot = string.find('.');  \n    std::string section_name = string.substr(0, index_dot);  \n    for (int j = 0; j < sections.size(); ++j) {  \n        for (int k = 0; k < sections[j].size(); ++k) {  \n            if (section_name == sections[j][k]) {  \n                for (int i = 0; i < count_dots - 1; ++i) {  \n                    string.erase(0, index_dot + 1);  \n                    index_dot = string.find('.');  \n                    section_name = string.substr(0, index_dot);  \n                    sections[j].push_back(section_name);  \n                }  \n                break; // уже обработали строку, дальше нет смысла  \n  \n            }  \n        }  \n    }  \n    for (int i = 0; i < count_dots; ++i) {  \n        if (sections.size() == 0) {  \n            std::vector<std::string> one_section;  \n            one_section.push_back(section_name);  \n            sections.push_back(one_section);  \n            string.erase(0, index_dot + 1);  \n            index_dot = string.find('.');  \n            section_name = string.substr(0, index_dot);  \n        } else {  \n            sections[sections.size() - 1].push_back(section_name);  \n            string.erase(0, index_dot + 1);  \n            index_dot = string.find('.');  \n            section_name = string.substr(0, index_dot);  \n        }  \n    }  \n}\n```"}
	],
	"edges":[]
}