{
	"nodes":[
		{"id":"88224160339a7bf8","x":513,"y":-478,"width":719,"height":1078,"color":"1","type":"text","text":"**Class ParserOMFL**\n ```cpp\nstd::vector<MultiValueClass> vector_multi_values = {}\nstd::vector<std::string> vector_key_names; // for checking repeated key_names\nfriend omfl::ParserOMFL& parse(const std::filesystem::path& path);  \nfriend omfl::ParserOMFL& parse(std::string str);\n```\n\n- **MultiValue multivalue** - \n\t- в нее будет класть объект из вектор метод гет и это значение будет использовать метод IsInt или AsIntOrDefault, изменять его и пушить в вектор обратно (такой же или уже измененный)\n"},
		{"id":"70548e448d90b21d","x":-1211,"y":-206,"width":1049,"height":952,"color":"3","type":"text","text":"## Parse(const std::strin str)\nparse(const std::string str)\n### Парсинг на key-value\n1. проверяю, есть ли равно в строке. Если нет - проверяю ==на секцию==. Если есть 1 равно - удаляю все пробелы до первого симола не пробела. Далее удаляю все пробелелы до равно после имени ключа. Далее удаляю пробелы после равно до первой буквы или цифры. Далее удаляю пробелы после значения ключа\n2. разделяю на key_name и key_value\n### Valid check for key_name\n1. Проверяю, есть ли запрещенные символы в названии ключа\n2. Проверяю, есть ли данный ключ в векторе key_names\n### Valid check for key_value\n1. Считаю сумму [  и ] и:\n\t- если 0 - не массив и не секция - проверяю на инт, флоат, стринг, бул\n\t- если %2=1 значит не валидно\n\t- если %2=0 значит массив\n2. для инта:\n\t- если первое значение в строке - это + или - или число - считаю колво точек. Если их > 1 - не валидно. Если 1 точка - случай с флоат. Если нет точек - смотрю, есть ли после первого элемента элементы, которые являются НЕ ЦИФРОЙ\n3. для стринга (от него отходит иф для инта, для була, а от инта отходит инт для флота)\n\t- Считаю колво кавычек - если 1 или  > 2 - не валидно (так как случай на массив уже рассмотрен). Если 2 кавычки - удаляю их из строки и если длина строки = 0 - не валидно (в тестах такого нет, но лучше так сделать)\n4. для флота:\n\t- смотрю на первый символ (+ либо - либо число). Если что то другое - значит не валидно. Далее разделяю строку на две - до точки и после точки. Если длина одной из этих строк == 0, значит не валидно. \n5. для була\n\t- если кавычек 0 и не инт, значит проверяю равенство строки к true или false\n6. для секции\n\t- \n7. для массива\n\t- разрешенная строка -"},
		{"id":"847f29caa29a0830","x":-200,"y":-709,"width":367,"height":361,"color":"#121fce","type":"text","text":"**parse(const std::filesystem::path & path)**\n-  построчно достаю строки из файла и кладу их в вектор lines_from_file\n- после того, как все строки считаны, прохожусь по вектору и вызываю функцию parse(const std::string str) и паршу строки"},
		{"id":"3794e9812144dda8","x":-1508,"y":881,"width":464,"height":420,"color":"4","type":"text","text":"Как удалять пробелы в строке\n```cpp\nstd::string string = \"       fal se     \";  \nstd::string str = string;  \nint index = string.find('=');  \nint i = 0;  \nwhile(string[i] == ' ') {  \n    string.erase(i, 1);  \n}  \nstd::reverse(string.begin(), string.end());  \nwhile(string[i] == ' ') {  \n    string.erase(i, 1);  \n}  \nstd::reverse(string.begin(), string.end());  \nstd::cout << string << std::endl;\n```"},
		{"id":"04b1915e0ea78ce7","x":-495,"y":-1627,"width":394,"height":101,"type":"text","text":"## namespace omfl"},
		{"id":"2beace61b4fe2650","x":-1755,"y":-1159,"width":842,"height":811,"color":"2","type":"text","text":"**Class MultiValue**\n- key_name\n- std::string key_value // будем даункастить эту переменную в инт, бул, флоат\n- char type_of_value // 0-int, 1-string 2-bool, 3-no any values\n- is_valid\n- - **bool valid()** -\n\t- возвращает значение флага is_valid\n- **Get(std::stirng str)**: ПЕРЕДЕЛАТЬ, ЧТОБЫ ОН ВОЗВРАЩАЛ ОБЪЕКТ КЛАССА MULTIVALUE\n\t- проходит по вектору multi_value_vector и находит в нем объект в котором есть ключ == str.\n\t- Записывает в переменную класса multiValue этот объект (чтобы потом AsInt IsInt или AsIntOrDefault могли к ней обращаться)\n- **AsInt()**:\n\t- обращается к key_value в omfl::ParserOMFL::multiValue при помощи typeid().name() возвращает тру или фолс\n- **IsInt()**:\n\t- при помощи typeid().name() возвращает тру или фолс\n- **IsFloat()**:\n\t- при помощи typeid().name() возвращает тру или фолс\n- **IsString()**:\n\t- при помощи typeid().name возвращает тру или фолс\n- **AsStringOrDefault(const std::string string**):\n\t- присваивает значение key_value значению переменной string\n- "}
	],
	"edges":[
		{"id":"47fc1b774bf36bf5","fromNode":"04b1915e0ea78ce7","fromSide":"bottom","toNode":"847f29caa29a0830","toSide":"top"},
		{"id":"a61f021ce215066b","fromNode":"04b1915e0ea78ce7","fromSide":"bottom","toNode":"2beace61b4fe2650","toSide":"top"},
		{"id":"74bd1fc0ad74447c","fromNode":"04b1915e0ea78ce7","fromSide":"right","toNode":"88224160339a7bf8","toSide":"top"},
		{"id":"9e51959db841ff91","fromNode":"847f29caa29a0830","fromSide":"right","toNode":"88224160339a7bf8","toSide":"left","color":"#000000","label":"friend"},
		{"id":"fee729f1aef8ea44","fromNode":"04b1915e0ea78ce7","fromSide":"bottom","toNode":"70548e448d90b21d","toSide":"top"},
		{"id":"2a86a5e8054e261c","fromNode":"70548e448d90b21d","fromSide":"bottom","toNode":"3794e9812144dda8","toSide":"top"}
	]
}