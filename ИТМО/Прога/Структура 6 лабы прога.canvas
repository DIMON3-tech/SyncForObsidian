{
	"nodes":[
		{"id":"04b1915e0ea78ce7","x":-495,"y":-1627,"width":394,"height":101,"color":"6","type":"text","text":"## namespace omfl"},
		{"id":"2beace61b4fe2650","x":-1978,"y":-1219,"width":842,"height":811,"color":"3","type":"text","text":"**Class MultiValue**\n- key_name\n- std::string key_value // будем даункастить эту переменную в инт, бул, флоат\n- char type_of_value // 0-int, 1-string 2-bool, 3-no any values\n- is_valid\n- - **bool valid()** -\n\t- возвращает значение флага is_valid\n- **Get(std::stirng str)**: ПЕРЕДЕЛАТЬ, ЧТОБЫ ОН ВОЗВРАЩАЛ ОБЪЕКТ КЛАССА MULTIVALUE\n\t- проходит по вектору multi_value_vector и находит в нем объект в котором есть ключ == str.\n\t- Записывает в переменную класса multiValue этот объект (чтобы потом AsInt IsInt или AsIntOrDefault могли к ней обращаться)\n- **AsInt()**:\n\t- обращается к key_value в omfl::ParserOMFL::multiValue при помощи typeid().name() возвращает тру или фолс\n- **IsInt()**:\n\t- при помощи typeid().name() возвращает тру или фолс\n- **IsFloat()**:\n\t- при помощи typeid().name() возвращает тру или фолс\n- **IsString()**:\n\t- при помощи typeid().name возвращает тру или фолс\n- **AsStringOrDefault(const std::string string**):\n\t- присваивает значение key_value значению переменной string\n- "},
		{"id":"70548e448d90b21d","x":-1136,"y":-408,"width":1049,"height":1094,"color":"5","type":"text","text":"## Parse(const std::strin str)\nparse(const std::string str)\n1. \n\n6. для секции\n\t- \n7. для массива\n\t- разрешенная строка - , [] все буквы и цифры (из другой разрешенной строки взять) \" .  - \n\t- если прошло проверку на разрешенные символы - получить вектор из значений массива\n\t- Пройтись по вектору и обнаружить, к какому типу принадлежит каждый элемент"},
		{"id":"847f29caa29a0830","x":-87,"y":-769,"width":367,"height":361,"color":"5","type":"text","text":"**parse(const std::filesystem::path & path)**\n-  построчно достаю строки из файла и кладу их в вектор lines_from_file\n- после того, как все строки считаны, прохожусь по вектору и вызываю функцию parse(const std::string str) и паршу строки"},
		{"id":"3794e9812144dda8","x":-1255,"y":746,"width":464,"height":420,"color":"4","type":"text","text":"Как удалять пробелы в строке\n```cpp\nstd::string string = \"       fal se     \";  \nstd::string str = string;  \nint index = string.find('=');  \nint i = 0;  \nwhile(string[i] == ' ') {  \n    string.erase(i, 1);  \n}  \nstd::reverse(string.begin(), string.end());  \nwhile(string[i] == ' ') {  \n    string.erase(i, 1);  \n}  \nstd::reverse(string.begin(), string.end());  \nstd::cout << string << std::endl;\n```"},
		{"id":"88224160339a7bf8","x":630,"y":-400,"width":719,"height":1078,"color":"1","type":"text","text":"**Class ParserOMFL**\n ```cpp\nstd::vector<MultiValueClass> vector_multi_values = {}\nstd::vector<std::string> vector_key_names; // for checking repeated key_names\nfriend omfl::ParserOMFL& parse(const std::filesystem::path& path);  \nfriend omfl::ParserOMFL& parse(std::string str);\n```\n\n- **MultiValue multivalue** - \n\t- в нее будет класть объект из вектор метод гет и это значение будет использовать метод IsInt или AsIntOrDefault, изменять его и пушить в вектор обратно (такой же или уже измененный)\n"},
		{"id":"6e8697712a5b7a72","x":-1982,"y":465,"width":250,"height":60,"type":"text","text":"WhichType"},
		{"id":"d97928f7ed80eacd","x":-1542,"y":-317,"width":329,"height":166,"type":"text","text":"bool CheckValidKeyName(std::string)"},
		{"id":"c6110c2a2a9f11f4","x":-1564,"y":-62,"width":374,"height":403,"type":"text","text":"bool CheckValidKeyValue(std::string)\n"},
		{"id":"b4539e6e2820b779","x":-761,"y":746,"width":674,"height":539,"color":"4","type":"text","text":"Как получить вектор значений массива\n```cpp\nstd::string str = \"1,2,3,4,6\";  \n  \nchar buff[str.length() + 1];  \nfor (int i = 0; i < str.length() - 1; ++i) {  \n    buff[i] = str[i];  \n}  \nstd::vector<std::string> vector;  \nchar* tmp_char;  \ntmp_char = strtok(buff, \",\");  \nwhile (tmp_char != nullptr) {  \n    vector.push_back(tmp_char);  \n    tmp_char = strtok(nullptr, \",\");  \n}  \nif (str[str.length() - 1] != ',') {  \n    vector.push_back(std::string(&str[str.length() - 1]));  \n}  \nfor (int i = 0; i < vector.size(); ++i) {  \n    std::cout << vector[i] << std::endl;  \n}\n```"}
	],
	"edges":[
		{"id":"47fc1b774bf36bf5","fromNode":"04b1915e0ea78ce7","fromSide":"bottom","toNode":"847f29caa29a0830","toSide":"top"},
		{"id":"a61f021ce215066b","fromNode":"04b1915e0ea78ce7","fromSide":"bottom","toNode":"2beace61b4fe2650","toSide":"top"},
		{"id":"74bd1fc0ad74447c","fromNode":"04b1915e0ea78ce7","fromSide":"right","toNode":"88224160339a7bf8","toSide":"top"},
		{"id":"9e51959db841ff91","fromNode":"847f29caa29a0830","fromSide":"right","toNode":"88224160339a7bf8","toSide":"left","color":"#000000","label":"friend"},
		{"id":"fee729f1aef8ea44","fromNode":"04b1915e0ea78ce7","fromSide":"bottom","toNode":"70548e448d90b21d","toSide":"top"},
		{"id":"2a86a5e8054e261c","fromNode":"70548e448d90b21d","fromSide":"bottom","toNode":"3794e9812144dda8","toSide":"top"},
		{"id":"bfa87f8f83351baa","fromNode":"70548e448d90b21d","fromSide":"bottom","toNode":"b4539e6e2820b779","toSide":"top"}
	]
}