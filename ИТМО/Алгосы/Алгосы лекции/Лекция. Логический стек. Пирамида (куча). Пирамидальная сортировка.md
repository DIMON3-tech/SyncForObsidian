==Регистр== позволяет зарезервировать ячейку


В случае массива, если большая часть памяти не используется, регистр конца смещается и теперь не вся память нами юзается (операц система сама управляет памятью)

==Системный стек== - саморегулируемый динамический стек

==Динамические структуры== нужны тогда, когда юзаем добавление и удаление


# Логический стек
- будем юзать динамические списки (нужны быстрые операции добавления и удаления)
- применяем принцип ==FILO== (первый зашел, последний вышел)
- когда делаем push(new): создается ячейка, новая ячейка ссылается на голову, потом ссылка head указывает на новую ячейку
- когда делаем pop: удаляем из головы (эффективно, потому что не надо искать элемент или проходить по стеку до конца, а просто делитнуть из головы). head = head.next (теперь голова это следующая ячейка), потом надо сделать, чтобы указатель удаленной ячейки ссылался на пустоту, потом сделать delete(p);
```cpp
  head = head.next;
  p.next = nullptr;
  delete(p);
  /* а еще, если есть коммерческая информация, ценная value, надо либо закодировать ее, чтобы нельзя было получить доступ к ней, либо просто обнулить (p = nullptr)
  /*
```

>[!Нельзя реализовать эффективную очередь (доставать и убирать за O(1)) на динамических списках.]


# Пирамида (куча). Пирамидальная сортировка
Улучшение сортировки выбором

## Сортировка выбором
1. прохожусь, нахожу самый большой, ставлю в конец
2. потом ищу между n-1 элементами самый большой, ставлю ее в конец
3. ищу между n-2 элементами самый большой, ставлю его в конец

# Смысл пирамидальной сортировки
- делю элементы на некоторые группы, прохожусь по массиву и закидываю элементы из группы N в одно место, элементы из группы K в другое место и тд...
- переход на следующий "уровень" происходит как на турнирах (по шахматам типа). Берем два челика, они играют и более скиловый (который победил) переходит дальше. Так получаем челика на первом месте. После того, как нашли большого челика, мы ищем второе и тд место среди тех, кто проиграл большому челику.
>[!неэффективность с точки зрения памяти (надо еще один массив держать)]

# Эффективная реализация пирамидальной сортировки (улучшение Флойда)
==Бинарное дерево== - когда у каждого элемента есть две стрелочки (типа два листочка). Пирамиду нельзя построить, если не достроить прошлый "уровень". В бинарном дереве это когда есть стрелочки у всех элементов на одном уровне.

==Высота дерева== - количество уровней

У всех царей, чем у бояр, у бояр больше, чем у помещиков и тд, но, кто "круче" из бояр или помещиков не важно. Каждый родитель больше их детей (кто важнее из детей - неважно).

# Пирамида
Это бинарное дерево высоты k , удовлевторяет следующим пунткам
- узлами дерева являются элементы массива
- распределение индексов в дереве не меняется. Всегда после 1 идет 2 и 3 (типа слева направо читается как 1, 2 3, 4 5 6 7 и тд)
- в верхушке всегда стоит максимум

# Как строится пирамида
- увеличиваем размер массива, записываем туда элемент
- затем сравниваем ребенка (который только что пришел) и его родителя (родитель определяется по индексу) и если ребенок больше родителя, меняем их местами (проверить больше или меньше можно только с родителем, ведь все, что выше уже отсортировано (типа инвариант))
- время строительства пирамиды - n * logn (каждый раз проходимся по высоте пирамиды и делаем так n раз, потому что n чисел)
- важно, в реализации siftUp добавить условие проверки, дошли ли мы до корня пирамиды (до самого высокого элемента)