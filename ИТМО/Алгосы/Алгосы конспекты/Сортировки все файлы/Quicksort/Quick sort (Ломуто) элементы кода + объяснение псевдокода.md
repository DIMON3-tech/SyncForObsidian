**Виды разбиений - это как переставлять элементы, а вот сама суть quick sort одна и та же для любых разбиений - разбить массив на 2 части и каждую снова разбить (уход в рекурсию)**
- Опорный элемент берется в конце (support = arr{ -1 })
- i = 0 в начале
- j = 0 (начало массива и идем до конца массива)
- Сравниваем arr{ j } с support. Если support > arr{ j }, тогда i увеличиваем на 1 (появился +1 элемент, меньший support, значит резервируем для него место в зоне меньших элементов). Далее меняем arr{ i } с arr{ j }
- Если support < arr{ j }, то i не трогаем, просто j++
- Когда j дошел до support, надо, чтобы support встал на место, где все левые элементы меньше его (та самая зона меньших элементов), а справа были элементы больше, чем он. Значит он должен встать на место i + 1 (свапаем arr{ j } и arr{ i+1 })
- Далее работаем отдельно с массивом меньших элементов и правым массивом и рассматриваем их как исходные (уход в рекурсию)
		![[Pasted image 20220930204532.png]]
